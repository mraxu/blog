
树莓派做网关
http://shumeipai.nxez.com/2013/10/26/raspberry-pi-make-a-vpn-gateway-router.html

http://blog.csdn.net/lostgdi/article/details/42643645





## 科学上网

### shadowsocks安装使用

sudo pip3 install shadowsocks

```json
{
	"server":"198.58.105.245",
	"server_port":"8388",
	"local_address":"0.0.0.0",
	"local_port":"1080",
	"password":"lf753951",
	"timeout":600,
	"method":"aes-256-cfb"
}
```
sudo sslocal -c ./conf.json -d start

检查端口是否开启
netstat -ntlp


### redsocks使用

```conf
base {
	// debug: connection progress & client list on SIGUSR1
	log_debug = off;

	// info: start and end of client session
	log_info = on;

	/* possible `log' values are:
	 *   stderr
	 *   "file:/path/to/file"
	 *   syslog:FACILITY  facility is any of "daemon", "local0"..."local7"
	 */
	log = "syslog:daemon";

	// detach from console
  //后台启动
	daemon = on;

	/* Change uid, gid and root directory, these options require root
	 * privilegies on startup.
	 * Note, your chroot may requre /etc/localtime if you write log to syslog.
	 * Log is opened before chroot & uid changing.
	 */
	user = redsocks;
	group = redsocks;
	// chroot = "/var/chroot";

	/* possible `redirector' values are:
	 *   iptables   - for Linux
	 *   ipf        - for FreeBSD
	 *   pf         - for OpenBSD
	 *   generic    - some generic redirector that MAY work
	 */
	redirector = iptables;
}

//主配置部分
redsocks {
	/* `local_ip' defaults to 127.0.0.1 for security reasons,
	 * use 0.0.0.0 if you want to listen on every interface.
	 * `local_*' are used as port to redirect to.
	 */
	local_ip = 0.0.0.0;
	local_port = 12345;

	// `ip' and `port' are IP and tcp-port of proxy-server
	// You can also use hostname instead of IP, only one (random)
	// address of multihomed host will be used.
	ip = 127.0.0.1;
  //下面这个是本地ss绑定的端口
	port = 1080;


	// known types: socks4, socks5, http-connect, http-relay
	type = socks5;

	// login = "foobar";
	// password = "baz";
}

redudp {
	// `local_ip' should not be 0.0.0.0 as it's also used for outgoing
	// packets that are sent as replies - and it should be fixed
	// if we want NAT to work properly.
	local_ip = 127.0.0.1;
	local_port = 10053;

	// `ip' and `port' of socks5 proxy server.
	ip = 10.0.0.1;
	port = 1080;
	login = username;
	password = pazzw0rd;

	// kernel does not give us this information, so we have to duplicate it
	// in both iptables rules and configuration file.  By the way, you can
	// set `local_ip' to 127.45.67.89 if you need more than 65535 ports to
	// forward ;-)
	// This limitation may be relaxed in future versions using contrack-tools.
	dest_ip = 8.8.8.8;
	dest_port = 53;

	udp_timeout = 30;
	udp_timeout_stream = 180;
}
//这部分是创建一个UDP转TCP的本地DNS服务器 用不到 可以注释掉
dnstc {
	// fake and really dumb DNS server that returns "truncated answer" to
	// every query via UDP, RFC-compliant resolver should repeat same query
	// via TCP in this case.
	local_ip = 127.0.0.1;
	local_port = 5300;
}

// you can add more `redsocks' and `redudp' sections if you need.
```

redsocks -c redsocks.conf



### 配置iptables防火墙


导入防火墙规则

my chain
```
# 创建一个新的规则
sudo iptables -t nat -N REDSOCKS

# Ignore LANs and some other reserved addresses.
# 忽略LANs和其他保留地址,不要将流量重定向到followign地址范围
# See http://en.wikipedia.org/wiki/Reserved_IP_addresses#Reserved_IPv4_addresses
# and http://tools.ietf.org/html/rfc5735 for full list of reserved networks.
# sudo iptables -t nat -A SHADOWSOCKS -d $server_IP -j RETURN
sudo iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN
sudo iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN
sudo iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN
sudo iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN
sudo iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN
sudo iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN
sudo iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN
sudo iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN


# 其他任何东西都应该重定向到端口12345
sudo iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345

# “luser”所连接的任何tcp连接都应该被重定向。
sudo iptables -t nat -A OUTPUT -p tcp -m owner --uid-owner luser -j REDSOCKS


```


```shell

sudo iptables -t nat -A OUTPUT -p tcp -j SHADOWSOCKS  
sudo iptables -t nat -A PREROUTING -p tcp -j SHADOWSOCKS  

-----------------------------------------------------------
iptables -t nat -N REDSOCKS
iptables -t nat -A PREROUTING -i br-lan -p tcp -j REDSOCKS


# Redirect normal HTTP and HTTPS traffic
# 重定向正常的HTTP和HTTPS通信
iptables -t nat -A REDSOCKS -p tcp --dport 80 -j REDIRECT --to-ports 11111
iptables -t nat -A REDSOCKS -p tcp --dport 443 -j REDIRECT --to-ports 11111


-----------------------------------------------------------


# Create new chain
# 创建一个新的规则
root# iptables -t nat -N REDSOCKS

# Ignore LANs and some other reserved addresses.
# 忽略LANs和其他保留地址。
# See http://en.wikipedia.org/wiki/Reserved_IP_addresses#Reserved_IPv4_addresses
# and http://tools.ietf.org/html/rfc5735 for full list of reserved networks.
root# iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN
root# iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN
root# iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN
root# iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN
root# iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN
root# iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN
root# iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN
root# iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN

# Anything else should be redirected to port 12345
# 其他任何东西都应该重定向到端口12345
root# iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345

# Any tcp connection made by `luser' should be redirected.
# “luser”所连接的任何tcp连接都应该被重定向。
root# iptables -t nat -A OUTPUT -p tcp -m owner --uid-owner luser -j REDSOCKS

```

iptables 文档:http://wiki.ubuntu.org.cn/IptablesHowTo


问题1


启动shadowsocks报错
```
INFO: loading config from ./conf.json
2017-12-07 07:31:11 INFO     loading libcrypto from libcrypto.so.1.1
Traceback (most recent call last):
  File "/usr/local/bin/sslocal", line 11, in <module>
    sys.exit(main())
  File "/usr/local/lib/python3.5/dist-packages/shadowsocks/local.py", line 39, in main
    config = shell.get_config(True)
  File "/usr/local/lib/python3.5/dist-packages/shadowsocks/shell.py", line 262, in get_config
    check_config(config, is_local)
  File "/usr/local/lib/python3.5/dist-packages/shadowsocks/shell.py", line 124, in check_config
    encrypt.try_cipher(config['password'], config['method'])
  File "/usr/local/lib/python3.5/dist-packages/shadowsocks/encrypt.py", line 44, in try_cipher
    Encryptor(key, method)
  File "/usr/local/lib/python3.5/dist-packages/shadowsocks/encrypt.py", line 83, in __init__
    random_string(self._method_info[1]))
  File "/usr/local/lib/python3.5/dist-packages/shadowsocks/encrypt.py", line 109, in get_cipher
    return m[2](method, key, iv, op)
  File "/usr/local/lib/python3.5/dist-packages/shadowsocks/crypto/openssl.py", line 76, in __init__
    load_openssl()
  File "/usr/local/lib/python3.5/dist-packages/shadowsocks/crypto/openssl.py", line 52, in load_openssl
    libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)
  File "/usr/lib/python3.5/ctypes/__init__.py", line 360, in __getattr__
    func = self.__getitem__(name)
  File "/usr/lib/python3.5/ctypes/__init__.py", line 365, in __getitem__
    func = self._FuncPtr((name_or_ordinal, self))
AttributeError: /usr/lib/arm-linux-gnueabihf/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup
```

此问题是升级openssl导致无法使用，旧版EVP_CIPHER_CTX_cleanup函数被弃用改为EVP_CIPHER_CTX_reset
解决
定位到/usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py文件：
修改52，111行处的EVP_CIPHER_CTX_cleanup为EVP_CIPHER_CTX_reset 重启服务，解决。
实际情况根据自己的ss版本查找修改相关文件
